// generated by Fast Light User Interface Designer (fluid) version 1.0106

#include "modelerui.h"

static inline void loadPosFile(string filename, vector<float> &posArray) {
    // cout << filename << endl;
    ifstream file(filename);
    int index;
    float val;
    while (file >> index >> val) {
        posArray.push_back(val);
    }
    file.close();
}

inline void ModelerUserInterface::cb_m_controlsWindow_i(Fl_Double_Window*, void*) {
    exit(0);
}
void ModelerUserInterface::cb_m_controlsWindow(Fl_Double_Window* o, void* v) {
    ((ModelerUserInterface*)(o->user_data()))->cb_m_controlsWindow_i(o,v);
}

inline void ModelerUserInterface::cb_Save_i(Fl_Menu_*, void*) {
    char *filename = NULL;
    filename = fl_file_chooser("Save BMP File", "*.bmp", NULL);
    if (filename)
    {
        int x = m_modelerView->x();
        int y = m_modelerView->y();
        int w = m_modelerView->w();
        int h = m_modelerView->h();

        m_modelerWindow->show();
    //	do {Sleep(10); }
    //	while (!m_modelerWindow->shown());
    //	m_modelerView->draw();
        m_modelerView->make_current();
        m_modelerView->draw();


        unsigned char *imageBuffer = new unsigned char[3*w*h];

        // Tell openGL to read from the front buffer when capturing
        // out paint strokes
        glReadBuffer(GL_BACK);

        glPixelStorei( GL_PACK_ALIGNMENT, 1 );
        glPixelStorei( GL_PACK_ROW_LENGTH, w );

        glReadPixels( 0, 0, w, h,
                        GL_RGB, GL_UNSIGNED_BYTE,
                        imageBuffer );


        writeBMP(filename, w,h, imageBuffer);

        delete [] imageBuffer;
    }
}
void ModelerUserInterface::cb_Save(Fl_Menu_* o, void* v) {
    ((ModelerUserInterface*)(o->parent()->user_data()))->cb_Save_i(o,v);
}

inline void ModelerUserInterface::cb_Open_i(Fl_Menu_*, void*) {
    char *filename = NULL;
    filename = fl_file_chooser("Open .pos File", "*.pos", NULL);

    if (filename)
    {
        std::ifstream ifs( filename );
        if( !ifs ) {
            std::cerr << "Error: couldn't read position file " << filename << std::endl;
            return;
        }

        int controlNum;
        float value;
        while( ifs >> controlNum >> value )
        {
            if( controlNum >= ModelerApplication::Instance()->GetNumControls() ) {
                break;
            }

            ModelerApplication::Instance()->SetControlValue(controlNum, value);
        }

        m_modelerView->update();
        m_modelerView->redraw();
    };
}
void ModelerUserInterface::cb_Open(Fl_Menu_* o, void* v) {
    ((ModelerUserInterface*)(o->parent()->user_data()))->cb_Open_i(o,v);
}

inline void ModelerUserInterface::cb_Save1_i(Fl_Menu_*, void*) {
    char *filename = NULL;
    filename = fl_file_chooser("Save .pos File", "*.pos", NULL);

    if (filename)
    {
        FILE* m_posFile = fopen(filename, "w");

        float elevation, azimuth, dolly, twist;

        double value;
        for(int i = 0; i < ModelerApplication::Instance()->GetNumControls(); i++)
        {
            value = ModelerApplication::Instance()->GetControlValue(i);

            fprintf(m_posFile, "%d %f\n", i, value);
        }

        fclose(m_posFile);
    };
}
void ModelerUserInterface::cb_Save1(Fl_Menu_* o, void* v) {
    ((ModelerUserInterface*)(o->parent()->user_data()))->cb_Save1_i(o,v);
}

inline void ModelerUserInterface::cb_Exit_i(Fl_Menu_*, void*) {
    m_controlsWindow->hide();
    m_modelerWindow->hide();
}
void ModelerUserInterface::cb_Exit(Fl_Menu_* o, void* v) {
    ((ModelerUserInterface*)(o->parent()->user_data()))->cb_Exit_i(o,v);
}

Fl_Menu_Item ModelerUserInterface::menu_m_controlsMenuBar[] = {
    {"File", 0,  0, 0, 64, 0, 0, 14, 56},
    {"Save Bitmap File", 0,  (Fl_Callback*)ModelerUserInterface::cb_Save, 0, 128, 0, 0, 14, 56},
    {"Open Position File", 0,  (Fl_Callback*)ModelerUserInterface::cb_Open, 0, 0, 0, 0, 14, 56},
    {"Save Position File", 0,  (Fl_Callback*)ModelerUserInterface::cb_Save1, 0, 128, 0, 0, 14, 56},
    {"Exit", 0,  (Fl_Callback*)ModelerUserInterface::cb_Exit, 0, 0, 0, 0, 14, 56},
    {0,0,0,0,0,0,0,0,0},
    {"Animate", 0,  0, 0, 64, 0, 0, 14, 56},
    // {"Enable", 0,  (Fl_Callback*)ModelerUserInterface::cb_m_controlsAnimOnMenu, 0, 2, 0, 0, 14, 56},
    {"Load Animation File", 0, (Fl_Callback*)ModelerUserInterface::cb_Load_Animate, 0, 128, 0, 0, 14, 56},
    {"Play Animation Once", 0, (Fl_Callback*)ModelerUserInterface::cb_Play_Animate_Once, 0, 0, 0, 0, 14, 56},
    {"Play Animation Repeatedly", 0, (Fl_Callback*)ModelerUserInterface::cb_Play_Animate_Repeat, 0, 2, 0, 0, 14, 56},
    {0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0}
};
Fl_Menu_Item* ModelerUserInterface::m_controlsAnimOnMenu = ModelerUserInterface::menu_m_controlsMenuBar + 9;

void ModelerUserInterface::cb_Load_Animate_i(Fl_Menu_* o, void* v) {
    // If playing animation now, then do nothing
    if (m_animating) return;

    auto app = ModelerApplication::Instance();
    char *animFilename = fl_file_chooser("Load Animation File", "*.anim", NULL);

    if (animFilename) {
        ifstream file(animFilename);
        string filename(animFilename), fileDir;
        float nextSecs;
        int nextFrames;
        vector<float> currentFrameControls;

        fileDir = "";
        if (filename.find('/') != string::npos)
            fileDir = filename.substr(0, filename.rfind('/') + 1);
        m_numFrames = 1;
        m_animateFrames.clear();

        file >> filename;
        loadPosFile(fileDir + filename, currentFrameControls);
        m_animateFrames.push_back(currentFrameControls);
        int numControls = currentFrameControls.size();
        auto frameIntervals = vector<float>(numControls);
        auto temp = vector<float>(numControls);
        while (file >> nextSecs >> filename) {
            nextFrames = (int) ceil(nextSecs * m_animateFps);
            currentFrameControls.clear();
            loadPosFile(fileDir + filename, currentFrameControls);
            auto &lastFrameControls = m_animateFrames.back();
            // Determine the interpolation interval for each control
            for (int i = 0; i < numControls; ++i) {
                // If the i-th control is for root translation, then interpolate as usual
                if (app->getControlIsTranslation(i)) {
                    frameIntervals[i] = (currentFrameControls[i] - lastFrameControls[i]) / nextFrames;
                }
                else {
                    float lastVal = lastFrameControls[i] + M_PI,
                        currentVal = currentFrameControls[i] + M_PI;
                    frameIntervals[i] = (abs(currentVal - lastVal) < 2 * M_PI - abs(currentVal - lastVal)
                        ? (currentVal - lastVal)
                        : (currentVal - lastVal < 0
                            ? 2 * M_PI - currentVal + lastVal
                            : currentVal - lastVal - 2 * M_PI)) / nextFrames;
                }
            }
            // Insert interpolated frame controls
            temp = lastFrameControls;
            for (int i = 0; i < nextFrames; ++i) {
                for (int j = 0; j < numControls; ++j)
                    temp[j] += frameIntervals[j];
                m_animateFrames.push_back(temp);
            }
            m_numFrames += nextFrames;
        }
        file.close();
        cout << "Animation file loaded. " << m_numFrames << " frames in total." << endl;
    }
}

void ModelerUserInterface::cb_Load_Animate(Fl_Menu_* o, void* v) {
    ((ModelerUserInterface*)(o->parent()->user_data()))->cb_Load_Animate_i(o, v);
}

void ModelerUserInterface::cb_Play_Animate_Once_i(Fl_Menu_* o, void* v) {
    // If animation file not loaded
    if (m_numFrames == 0) return;

    // If it is now animating, then does nothing
    if (m_animating) return;

    // Notify timer function to play animation
    m_currentFrame = 0;
    m_startTime = 0;
    m_animating = true;
}

void ModelerUserInterface::cb_Play_Animate_Once(Fl_Menu_* o, void* v) {
    ((ModelerUserInterface*)(o->parent()->user_data()))->cb_Play_Animate_Once_i(o, v);
}

void ModelerUserInterface::cb_Play_Animate_Repeat_i(Fl_Menu_* o, void* v) {
    m_isPlayRepeat = m_controlsAnimOnMenu->value() != 0;
    if (m_isPlayRepeat) {
        if (m_numFrames > 0) {
            m_currentFrame = 0;
            m_startTime = 0;
            m_animating = true;
        }
    }
    else {
        m_animating = false;
    }
}

void ModelerUserInterface::cb_Play_Animate_Repeat(Fl_Menu_* o, void* v) {
    ((ModelerUserInterface*)(o->parent()->user_data()))->cb_Play_Animate_Repeat_i(o, v);
}

inline void ModelerUserInterface::cb_m_controlsBrowser_i(Fl_Browser*, void*) {
    auto app = ModelerApplication::Instance();
    for (int i = 0, numControls = app->GetNumControls(); i < numControls; ++i) {
        int selectorIndex = app->getControlToSelector(i);
        if (m_controlsBrowser->selected(selectorIndex))
            app->ShowControl(i);
        else
            app->HideControl(i);
    }
    app->redrawControlsWindow();
}
void ModelerUserInterface::cb_m_controlsBrowser(Fl_Browser* o, void* v) {
    ((ModelerUserInterface*)(o->parent()->user_data()))->cb_m_controlsBrowser_i(o,v);
}

inline void ModelerUserInterface::cb_m_modelerWindow_i(Fl_Double_Window*, void*) {
    exit(0);
}
void ModelerUserInterface::cb_m_modelerWindow(Fl_Double_Window* o, void* v) {
    ((ModelerUserInterface*)(o->user_data()))->cb_m_modelerWindow_i(o,v);
}

ModelerUserInterface::ModelerUserInterface() {
    Fl_Double_Window* w;
    { Fl_Double_Window* o = m_controlsWindow = new Fl_Double_Window(395, 325, "Assignment 2 Controls");
        w = o;
        o->callback((Fl_Callback*)cb_m_controlsWindow, (void*)(this));
        o->when(FL_WHEN_NEVER);
        { Fl_Menu_Bar* o = m_controlsMenuBar = new Fl_Menu_Bar(0, 0, 395, 25);
            o->menu(menu_m_controlsMenuBar);
        }
        { Fl_Browser* o = m_controlsBrowser = new Fl_Browser(0, 25, 140, 300, "Controls");
            o->type(3);
            o->textsize(10);
            o->callback((Fl_Callback*)cb_m_controlsBrowser);
            Fl_Group::current()->resizable(o);
        }
        { Fl_Scroll* o = m_controlsScroll = new Fl_Scroll(145, 25, 250, 300);
            o->type(6);
            o->when(FL_WHEN_CHANGED);
            { Fl_Pack* o = m_controlsPack = new Fl_Pack(145, 25, 225, 300);
                o->end();
            }
            o->end();
        }
        o->end();
    }
    { Fl_Double_Window* o = m_modelerWindow = new Fl_Double_Window( 800, 800, "Assignment 2 Model");
        w = o;
        o->callback((Fl_Callback*)cb_m_modelerWindow, (void*)(this));
        o->when(FL_WHEN_NEVER);
        { ModelerView* o = m_modelerView = new ModelerView(0, 0, 800, 800, "ModelerView");
            o->box(FL_NO_BOX);
            o->color(FL_BACKGROUND_COLOR);
            o->selection_color(FL_BACKGROUND_COLOR);
            o->labeltype(FL_NORMAL_LABEL);
            o->labelfont(0);
            o->labelsize(14);
            o->labelcolor(FL_BLACK);
            o->align(FL_ALIGN_CENTER);
            o->when(FL_WHEN_RELEASE);
            Fl_Group::current()->resizable(o);
        }
        o->end();
    }

    m_animateFps = 30;
    m_numFrames = 0;
    m_isPlayRepeat = m_animating = false;
    // Set up timer function for playing animation
    Fl::add_timeout(1.0 / m_animateFps, animationCallback, (void *)this);
}

void ModelerUserInterface::animationCallback(void *that) {
    ModelerUserInterface *ui = static_cast<ModelerUserInterface*>(that);
    double delaySecs = 1.0 / ui->m_animateFps;
    if (ui->m_startTime > 0) {
        float elapsedTime = (float)(clock() - ui->m_startTime) / CLOCKS_PER_SEC;
        delaySecs += delaySecs - elapsedTime;
    }
    ui->m_startTime = clock();
    Fl::repeat_timeout(max(delaySecs, 0.001), animationCallback, that);

    // If it is animating now, then render the current frame
    if (ui->m_animating) {
        auto &controls = ui->m_animateFrames[ui->m_currentFrame];
        auto app = ModelerApplication::Instance();
        for (int i = 0, numControls = controls.size(); i < numControls; ++i) {
            app->SetControlValue(i, controls[i]);
        }
        ui->m_modelerView->update();
        ui->m_modelerView->redraw();
        ui->m_currentFrame = (ui->m_currentFrame + 1) % ui->m_numFrames;

        // Stop animating if the user only wants to play once, and the last frame is shown
        if (ui->m_currentFrame == 0 && !ui->m_isPlayRepeat)
            ui->m_animating = false;
    }
}

void ModelerUserInterface::show() {
    m_controlsWindow->show();
    m_modelerWindow->show();
    m_modelerView->show();
}
